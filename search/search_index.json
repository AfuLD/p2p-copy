{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"p2p-copy","text":"<p>p2p-copy is a Python library and command-line tool for transferring files and directories over a WebSocket relay server. It supports chunked streaming, optional end-to-end encryption, compression, and resume functionality, making it suitable for environments with restrictive firewalls, such as high-performance computing (HPC) systems. The tool avoids dependencies on SSH or inbound ports, relying instead on outbound connections over ports like 443.</p> <p>The design prioritizes performance, low resource usage, and simplicity, with a stateless relay that forwards data without storage. For details on the protocol and internals, see Features.</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Install via pip:</p> <pre><code>pip install p2p-copy[security]\n</code></pre>"},{"location":"#run-relay-one-terminal","title":"Run Relay (one terminal)","text":"<pre><code>p2p-copy run-relay-server localhost 8765 --no-tls  # For development\n# Or with TLS: --tls --certfile cert.pem --keyfile key.pem\n</code></pre>"},{"location":"#send-files-another-terminal","title":"Send Files (another terminal)","text":"<pre><code>p2p-copy send ws://localhost:8765 mysecretcode /path/to/files_or_dirs --encrypt --compress on --resume\n</code></pre>"},{"location":"#receive-third-terminal","title":"Receive (third terminal)","text":"<pre><code>p2p-copy receive ws://localhost:8765 mysecretcode --out ./downloads --encrypt\n</code></pre> <p>Use the same <code>mysecretcode</code> for sender and receiver pairing. For full CLI details, see Usage. For production relay setup, see Relay Setup.</p>"},{"location":"#key-aspects","title":"Key Aspects","text":"<ul> <li>Pairing and Transfer: Clients connect to a relay using a shared code (hashed for security). Files are streamed in chunks with integrity checks.</li> <li>Optional Features: End-to-end encryption (AES-GCM with Argon2-derived keys), per-file compression (Zstandard), and the option to resume partial transfers.</li> <li>Use Cases: Designed for HPC workflows where traditional tools like SCP or rsync are limited by firewalls or configuration requirements.</li> <li>API Integration: Embeddable in Python scripts; see API.</li> </ul> <p>For installation instructions, see Installation. For module structure, see Module Layout.</p>"},{"location":"api/","title":"API Reference","text":"<p>This section documents the public API of <code>p2p_copy</code>. For module structure, see Module Layout. Generated from source code docstrings.</p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p> </p> <p>For api usage examples, see APIExamples. For feature details, see Features.</p>"},{"location":"api/#p2p_copy.api","title":"api","text":""},{"location":"api/#p2p_copy.api.send","title":"send  <code>async</code>","text":"<pre><code>send(server, code, files, *, encrypt=False, compress=CompressMode.auto, resume=False)\n</code></pre> <p>Send files/directories to a receiver via the relay server.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>str</code> <p>The WebSocket server URL (ws:// or wss://).</p> required <code>code</code> <code>str</code> <p>The shared passphrase/code for pairing.</p> required <code>files</code> <code>List[str]</code> <p>List of files and/or directories to send.</p> required <code>encrypt</code> <code>bool</code> <p>Enable end-to-end encryption. Default is False. Receiver needs to use the same setting.</p> <code>False</code> <code>compress</code> <code>CompressMode</code> <p>Compression mode. Default is 'auto'.</p> <code>auto</code> <code>resume</code> <code>bool</code> <p>Enable resume of partial transfers. Default is False. If True, attempt to skip identical files and append incomplete files based on receiver feedback.</p> <code>False</code> <p>Returns:</p> Type Description <code>int</code> <p>Exit code: 0 on success, non-zero on error.</p> Notes <ul> <li>Supports resuming by comparing checksums of partial files.</li> <li>Uses chunked streaming for large files.</li> </ul> Source code in <code>src/p2p_copy/api.py</code> <pre><code>async def send(server: str, code: str, files: List[str],\n               *, encrypt: bool = False,\n               compress: CompressMode = CompressMode.auto,\n               resume: bool = False) -&gt; int:\n    \"\"\"\n    Send files/directories to a receiver via the relay server.\n\n    Parameters\n    ----------\n    server : str\n        The WebSocket server URL (ws:// or wss://).\n    code : str\n        The shared passphrase/code for pairing.\n    files : List[str]\n        List of files and/or directories to send.\n    encrypt : bool, optional\n        Enable end-to-end encryption. Default is False.\n        Receiver needs to use the same setting.\n    compress : CompressMode, optional\n        Compression mode. Default is 'auto'.\n    resume : bool, optional\n        Enable resume of partial transfers. Default is False.\n        If True, attempt to skip identical files and append\n        incomplete files based on receiver feedback.\n\n    Returns\n    -------\n    int\n        Exit code: 0 on success, non-zero on error.\n\n    Notes\n    -----\n    - Supports resuming by comparing checksums of partial files.\n    - Uses chunked streaming for large files.\n    \"\"\"\n\n    # Closures to break up functions for readability\n\n    async def wait_for_receiver_ready():\n        try:\n            ready_frame = await asyncio.wait_for(ws.recv(), timeout=300)  # 300s Timeout\n            if isinstance(ready_frame, str):\n                ready = loads(ready_frame)\n                if ready.get(\"type\") != \"ready\":\n                    print(\"[p2p_copy] send(): unexpected frame after hello\")\n                    return 3\n            else:\n                print(\"[p2p_copy] send(): expected text frame after hello\")\n                return 3\n        except asyncio.TimeoutError:\n            print(\"[p2p_copy] send(): timeout waiting for ready\")\n            return 3\n\n    async def wait_for_receiver_resume_manifest():\n        try:\n            raw = await asyncio.wait_for(ws.recv(), timeout=30)\n        except asyncio.TimeoutError:\n            print(\"[p2p_copy] send(): timeout waiting for receiver_manifest\")\n            return 3\n        if isinstance(raw, str):\n            o = loads(raw)\n            t = o.get(\"type\")\n            if t == \"enc_receiver_manifest\" and encrypt:\n                try:\n                    hidden = bytes.fromhex(o[\"hidden_manifest\"])\n                    m_str = secure.decrypt_chunk(hidden).decode()\n                    o = loads(m_str)\n                    t = o.get(\"type\")\n                except Exception:\n                    print(\"[p2p_copy] send():  failed to decrypt encrypted receiver manifest\")\n                    return 3\n\n            if t == \"receiver_manifest\":\n                for e in o.get(\"entries\", []):\n                    try:\n                        p = e[\"path\"]\n                        sz = int(e[\"size\"])\n                        ch = bytes.fromhex(e[\"chain_hex\"])\n                        resume_map[p] = (sz, ch)\n                    except Exception:\n                        print(\"[p2p_copy] send():  failed to read receiver manifest\")\n                        return 3\n\n    async def pairing_with_receiver():\n        await ws.send(hello)\n        if receiver_not_ready := await wait_for_receiver_ready():\n            return receiver_not_ready\n\n        # Send file infos to receiver\n        await ws.send(manifest)\n\n        # wait for receiver resume manifest (optionally encrypted)\n        if resume and (no_response_manifest := await wait_for_receiver_resume_manifest()):\n            return no_response_manifest\n\n    async def determine_file_resume_point():\n        hint = resume_map.get(rel_p.as_posix())\n        if hint is not None:\n            recv_size, recv_chain = hint\n            if 0 &lt; recv_size &lt;= size:\n                hashed, local_chain = await compute_chain_up_to(abs_p, limit=recv_size)\n                if hashed == recv_size and local_chain == recv_chain:\n                    return recv_size\n                else:\n                    # mismatch -&gt; overwrite from scratch\n                    return 0\n        return 0\n\n    async def send_file():\n        append_from = 0\n        # Determine resume point (optional)\n        if resume and (append_from := await determine_file_resume_point()) == size:\n            return  # Receiver already has identical file -&gt; skip\n\n        # Open file and optionally seek resume point\n        with abs_p.open(\"rb\") as fp:\n            if append_from:\n                await asyncio.to_thread(fp.seek, append_from, 0)\n\n            # Initialize per-transfer chain and sequence\n            chained_checksum = ChainedChecksum()\n            seq = 0\n\n            # Determine whether to use compression by compressing the first chunk\n            chunk = await asyncio.to_thread(fp.read, CHUNK_SIZE)\n            chunk = await Compressor.determine_compression(compressor, chunk)\n\n            # Build the complete file info header\n            file_info = file_begin(rel_p.as_posix(), size, compressor.compression_type, append_from=append_from)\n\n            # Optionally encrypt the file info\n            if encrypt:\n                enc_file_info = secure.encrypt_chunk(file_info.encode())\n                file_info = encrypted_file_begin(enc_file_info)\n\n            # Send file info header\n            await ws.send(file_info)\n\n            # Prepare the first frame, first chunk is optionally compressed and then encrypted\n            frame: bytes = pack_chunk(seq, chained_checksum.next_hash(chunk), secure.encrypt_chunk(chunk))\n            seq += 1\n\n            def next_frame():\n                \"\"\"prepares the next frame of a file to send, optionally compresses and encrypts\"\"\"\n                compressed_chunk = compressor.compress(chunk)\n                enc_chunk = secure.encrypt_chunk(compressed_chunk)\n                return pack_chunk(seq, chained_checksum.next_hash(compressed_chunk), enc_chunk)\n\n            # Send remaining chunks\n            async for chunk in read_in_chunks(fp):\n                # Next frame gets prepared in a parallel thread\n                next_frame_coro = asyncio.to_thread(next_frame)\n                # Send the current frame while next frame gets prepared\n                await ws.send(frame)\n                # Complete the next frame\n                frame: bytes = await next_frame_coro\n                seq += 1\n\n        # Send the last frame\n        await ws.send(frame)\n        await ws.send(FILE_EOF)\n\n    # End of Closures\n\n    # Build manifest entries from given file list\n    resolved_file_list: List[Tuple[Path, Path, int]] = list(iter_manifest_entries(files))\n    if not resolved_file_list:\n        print(\"[p2p_copy] send(): no legal files where passed\")\n        return 3\n\n    entries: List[ManifestEntry] = [ManifestEntry(path=rel.as_posix(), size=size) for (_, rel, size) in\n                                    resolved_file_list]\n\n    # Initialize security-handler, compressor\n    secure = SecurityHandler(code, encrypt)\n    compressor = Compressor(mode=compress)\n\n    hello = Hello(type=\"hello\", code_hash_hex=secure.code_hash.hex(), role=\"sender\").to_json()\n    manifest = Manifest(type=\"manifest\", resume=resume, entries=entries).to_json()\n    if encrypt:  # Optionally encrypt the manifest\n        manifest = secure.build_encrypted_manifest(manifest)\n\n    # Connect to relay (disable WebSocket internal compression)\n    async with connect(server, max_size=2**21, compression=None) as ws:\n        # Stores info returned by the sender about what files are already present\n        resume_map: Dict[str, Tuple[int, bytes]] = {}\n        # Attempt to connect and optionally exchange info with receiver\n        if pairing_failed := await pairing_with_receiver():\n            return pairing_failed\n\n        # Transfer each file\n        for abs_p, rel_p, size in resolved_file_list:\n            await send_file()\n\n        # All done, send message to confirm the end of the copying process\n        await ws.send(EOF)\n        # Return non-error code\n        return 0\n</code></pre>"},{"location":"api/#p2p_copy.api.receive","title":"receive  <code>async</code>","text":"<pre><code>receive(server, code, *, encrypt=False, out=None)\n</code></pre> <p>Receive files from a sender via the relay server.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>str</code> <p>The WebSocket server URL (ws:// or wss://).</p> required <code>code</code> <code>str</code> <p>The shared passphrase/code for pairing.</p> required <code>encrypt</code> <code>bool</code> <p>Enable end-to-end encryption. Default is False. Sender needs to use the same setting.</p> <code>False</code> <code>out</code> <code>str</code> <p>Output directory. Default is current directory.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>Exit code: 0 on success, non-zero on error.</p> Notes <ul> <li>Supports resume if sender requests it.</li> <li>Writes files to the output directory, preserving relative paths.</li> <li>Info on whether to resume and compress is received from the sender</li> </ul> Source code in <code>src/p2p_copy/api.py</code> <pre><code>async def receive(server: str, code: str,\n                  *, encrypt: bool = False,\n                  out: Optional[str] = None) -&gt; int:\n    \"\"\"\n    Receive files from a sender via the relay server.\n\n    Parameters\n    ----------\n    server : str\n        The WebSocket server URL (ws:// or wss://).\n    code : str\n        The shared passphrase/code for pairing.\n    encrypt : bool, optional\n        Enable end-to-end encryption. Default is False.\n        Sender needs to use the same setting.\n    out : str, optional\n        Output directory. Default is current directory.\n\n    Returns\n    -------\n    int\n        Exit code: 0 on success, non-zero on error.\n\n    Notes\n    -----\n    - Supports resume if sender requests it.\n    - Writes files to the output directory, preserving relative paths.\n    - Info on whether to resume and compress is received from the sender\n    \"\"\"\n\n    # Closures to break up functions for readability\n\n    def return_with_error_code(msg: str = \"\"):\n        if cur_fp is not None:\n            cur_fp.close()\n        if msg:\n            print(f\"[p2p_copy] receive(): {msg}\")\n        return 4\n\n    async def handle_enc_manifest(o: dict):\n        try:\n            nonce_hex = o.get(\"nonce\")\n            secure.nonce_hasher.next_hash(bytes.fromhex(nonce_hex))\n            hidden = bytes.fromhex(o[\"hidden_manifest\"])\n            manifest_str = secure.decrypt_chunk(hidden).decode()\n            o = loads(manifest_str)\n            await handle_manifest(o)  # Delegate to plain handler\n        except Exception as e:\n            raise ValueError(f\"Failed to decrypt manifest: {e}\")\n\n    async def handle_manifest(o: dict):\n        resume = o.get(\"resume\", False)\n        if resume:\n            entries = o.get(\"entries\", [])\n            reply_entries: List[ReceiverManifestEntry] = []\n\n            for e in entries:\n                try:\n                    rel = Path(e[\"path\"])\n                    local_path = (out_dir / rel).resolve()\n                    if local_path.is_file():\n                        local_size = local_path.stat().st_size\n                        if local_size &gt; 0:\n                            hashed, chain_b = await compute_chain_up_to(local_path)\n                            resume_known[rel.as_posix()] = (hashed, chain_b)\n                            reply_entries.append(\n                                ReceiverManifestEntry(\n                                    path=rel.as_posix(),\n                                    size=hashed,\n                                    chain_hex=chain_b.hex(),\n                                )\n                            )\n                except Exception:\n                    continue  # Skip bad entries\n\n            if encrypt:\n                clear = ReceiverManifest(type=\"receiver_manifest\", entries=reply_entries).to_json().encode()\n                hidden = secure.encrypt_chunk(clear)\n                reply = EncryptedReceiverManifest(\n                    type=\"enc_receiver_manifest\",\n                    hidden_manifest=hidden.hex()\n                ).to_json()\n                await ws.send(reply)\n            else:\n                await ws.send(ReceiverManifest(type=\"receiver_manifest\", entries=reply_entries).to_json())\n\n    async def handle_enc_file(o: dict):\n        try:\n            hidden = bytes.fromhex(o[\"hidden_file\"])\n            file_str = secure.decrypt_chunk(hidden).decode()\n            o = loads(file_str)\n            await handle_file(o)\n        except Exception as e:\n            raise ValueError(f\"Failed to decrypt file info: {e}\")\n\n    async def handle_file(o: dict):\n        nonlocal cur_fp, cur_expected_size, cur_seq_expected, bytes_written, compressor, chained_checksum\n        if cur_fp is not None:\n            raise ValueError(\"Got new file while previous still open\")\n        try:\n            rel_path = o[\"path\"]\n            total_size: int = o.get(\"size\")\n            compression = o.get(\"compression\", \"none\")\n            append_from: int = o.get(\"append_from\", 0)\n        except Exception:\n            raise ValueError(f\"Bad file header: {o}\")\n\n        dest = (out_dir / Path(rel_path)).resolve()\n        ensure_dir(dest.parent)\n\n        open_mode = \"wb\"\n        expected_remaining = total_size\n        if append_from &gt; 0 and dest.exists() and dest.is_file():\n            local_size = dest.stat().st_size\n            if 0 &lt;= append_from &lt;= total_size and local_size == append_from:\n                open_mode = \"ab\"\n                expected_remaining = total_size - append_from\n            else:\n                expected_remaining = total_size\n\n        cur_fp = dest.open(open_mode)\n        cur_expected_size = expected_remaining\n        cur_seq_expected = 0\n        bytes_written = 0\n        compressor.set_decompression(compression)\n        chained_checksum = ChainedChecksum()\n\n    async def handle_file_eof(o: dict):\n        nonlocal cur_fp\n        if cur_fp is None:\n            raise ValueError(\"Got file_eof without open file\")\n        if cur_expected_size is not None and bytes_written != cur_expected_size:\n            raise ValueError(f\"Size mismatch: {bytes_written} != {cur_expected_size}\")\n        cur_fp.close()\n        cur_fp = None\n\n    async def handle_chunk():\n        nonlocal bytes_written, cur_seq_expected\n        if cur_fp is None:\n            raise ValueError(\"Unexpected binary data without open file\")\n        seq, chain, payload = unpack_chunk(frame)\n        if seq != cur_seq_expected:\n            raise ValueError(f\"Sequence mismatch: {seq} != {cur_seq_expected}\")\n\n        raw_payload = secure.decrypt_chunk(payload) if encrypt else payload\n        if chained_checksum.next_hash(raw_payload) != chain:\n            raise ValueError(\"Chained checksum mismatch\")\n\n        chunk = compressor.decompress(raw_payload)\n        await asyncio.to_thread(cur_fp.write, chunk)\n\n        bytes_written += len(chunk)\n        cur_seq_expected += 1\n\n    async def handle_eof(o: dict):\n        raise StopAsyncIteration  # Break the loop cleanly\n\n    # Frame type dispatcher\n    async def dispatch_frame():\n        if isinstance(frame, (bytes, bytearray)):\n            await handle_chunk()\n\n        elif not isinstance(frame, str):\n            raise ValueError(\"Unknown frame type\")\n\n        else:\n            o = loads(frame)\n            t = o.get(\"type\")\n\n            handlers = {\n                \"enc_manifest\": handle_enc_manifest if encrypt else None,\n                \"manifest\": handle_manifest if not encrypt else None,\n                \"enc_file\": handle_enc_file if encrypt else None,\n                \"file\": handle_file if not encrypt else None,\n                \"file_eof\": handle_file_eof,\n                \"eof\": handle_eof,\n            }\n            handler = handlers.get(t)\n            if handler is None:\n                raise ValueError(f\"Unexpected control: {o}\")\n            await handler(o)\n\n    # End of Closures\n\n    out_dir = Path(out or \".\")\n    ensure_dir(out_dir)\n\n    secure = SecurityHandler(code, encrypt)\n    hello = Hello(type=\"hello\", code_hash_hex=secure.code_hash.hex(), role=\"receiver\").to_json()\n\n    # Receiver state\n    cur_fp: Optional[BinaryIO] = None\n    cur_expected_size: Optional[int] = None\n    cur_seq_expected = 0\n    bytes_written = 0\n    chained_checksum = ChainedChecksum()\n    compressor = Compressor()\n    resume_known: Dict[str, Tuple[int, bytes]] = {}\n\n    async with connect(server, max_size=2**21, compression=None) as ws:\n        await ws.send(hello)\n        try:\n            async for frame in ws:\n                await dispatch_frame()\n        except StopAsyncIteration:\n            pass  # Normal EOF\n        except ValueError as e:\n            return return_with_error_code(str(e))\n\n    if cur_fp is not None:\n        return return_with_error_code(\"Stream ended while file open\")\n    return 0\n</code></pre>"},{"location":"api/#p2p_copy.security","title":"security","text":""},{"location":"api/#p2p_copy.security.SecurityHandler","title":"SecurityHandler","text":"<p>Handle security operations like hashing, encryption, and decryption for transfers.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>The shared passphrase/code.</p> required <code>encrypt</code> <code>bool</code> <p>Whether to enable end-to-end encryption.</p> required Source code in <code>src/p2p_copy/security.py</code> <pre><code>class SecurityHandler:\n    \"\"\"\n    Handle security operations like hashing, encryption, and decryption for transfers.\n\n    Parameters\n    ----------\n    code : str\n        The shared passphrase/code.\n    encrypt : bool\n        Whether to enable end-to-end encryption.\n    \"\"\"\n\n    def __init__(self, code: str, encrypt: bool):\n        self.encrypt = encrypt\n        if self.encrypt:\n            import_optional_security_libs()\n            self.code_hash = _get_argon2_hash(code, b\"code_hash used for hello-match\")\n            self.nonce_hasher = ChainedChecksum()\n            self.cipher = AESGCM(_get_argon2_hash(code, b\"cipher used for E2E-encryption\"))\n        else:\n            self.code_hash = hashlib.sha256(code.encode()).digest()\n\n    def encrypt_chunk(self, chunk: bytes) -&gt; bytes:\n        \"\"\"\n        Encrypt a chunk if encryption is enabled.\n\n        Parameters\n        ----------\n        chunk : bytes\n            The chunk to encrypt.\n\n        Returns\n        -------\n        bytes\n            The encrypted chunk, or original if not encrypted.\n        \"\"\"\n        if self.encrypt:\n            return self.cipher.encrypt(self.nonce_hasher.next_hash(), chunk, None)\n        return chunk\n\n    def decrypt_chunk(self, chunk: bytes) -&gt; bytes:\n        \"\"\"\n        Decrypt a chunk if encryption is enabled.\n\n        Parameters\n        ----------\n        chunk : bytes\n            The chunk to decrypt.\n\n        Returns\n        -------\n        bytes\n            The decrypted chunk, or original if not encrypted.\n        \"\"\"\n        if self.encrypt:\n            return self.cipher.decrypt(self.nonce_hasher.next_hash(), chunk, None)\n        return chunk\n\n    def build_encrypted_manifest(self, manifest: str) -&gt; str:\n        \"\"\"\n        Build an encrypted manifest for secure transmission.\n\n        Parameters\n        ----------\n        manifest : str\n            The plaintext manifest JSON.\n\n        Returns\n        -------\n        str\n            The JSON-serialized EncryptedManifest.\n        \"\"\"\n        start_nonce = os.urandom(32)\n        self.nonce_hasher.next_hash(start_nonce)\n        enc_manifest = self.encrypt_chunk(manifest.encode())\n        return EncryptedManifest(\n            type=\"enc_manifest\",\n            nonce=start_nonce.hex(),\n            hidden_manifest=enc_manifest.hex()\n        ).to_json()\n</code></pre>"},{"location":"api/#p2p_copy.security.SecurityHandler.encrypt_chunk","title":"encrypt_chunk","text":"<pre><code>encrypt_chunk(chunk)\n</code></pre> <p>Encrypt a chunk if encryption is enabled.</p> <p>Parameters:</p> Name Type Description Default <code>chunk</code> <code>bytes</code> <p>The chunk to encrypt.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The encrypted chunk, or original if not encrypted.</p> Source code in <code>src/p2p_copy/security.py</code> <pre><code>def encrypt_chunk(self, chunk: bytes) -&gt; bytes:\n    \"\"\"\n    Encrypt a chunk if encryption is enabled.\n\n    Parameters\n    ----------\n    chunk : bytes\n        The chunk to encrypt.\n\n    Returns\n    -------\n    bytes\n        The encrypted chunk, or original if not encrypted.\n    \"\"\"\n    if self.encrypt:\n        return self.cipher.encrypt(self.nonce_hasher.next_hash(), chunk, None)\n    return chunk\n</code></pre>"},{"location":"api/#p2p_copy.security.SecurityHandler.decrypt_chunk","title":"decrypt_chunk","text":"<pre><code>decrypt_chunk(chunk)\n</code></pre> <p>Decrypt a chunk if encryption is enabled.</p> <p>Parameters:</p> Name Type Description Default <code>chunk</code> <code>bytes</code> <p>The chunk to decrypt.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The decrypted chunk, or original if not encrypted.</p> Source code in <code>src/p2p_copy/security.py</code> <pre><code>def decrypt_chunk(self, chunk: bytes) -&gt; bytes:\n    \"\"\"\n    Decrypt a chunk if encryption is enabled.\n\n    Parameters\n    ----------\n    chunk : bytes\n        The chunk to decrypt.\n\n    Returns\n    -------\n    bytes\n        The decrypted chunk, or original if not encrypted.\n    \"\"\"\n    if self.encrypt:\n        return self.cipher.decrypt(self.nonce_hasher.next_hash(), chunk, None)\n    return chunk\n</code></pre>"},{"location":"api/#p2p_copy.security.SecurityHandler.build_encrypted_manifest","title":"build_encrypted_manifest","text":"<pre><code>build_encrypted_manifest(manifest)\n</code></pre> <p>Build an encrypted manifest for secure transmission.</p> <p>Parameters:</p> Name Type Description Default <code>manifest</code> <code>str</code> <p>The plaintext manifest JSON.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The JSON-serialized EncryptedManifest.</p> Source code in <code>src/p2p_copy/security.py</code> <pre><code>def build_encrypted_manifest(self, manifest: str) -&gt; str:\n    \"\"\"\n    Build an encrypted manifest for secure transmission.\n\n    Parameters\n    ----------\n    manifest : str\n        The plaintext manifest JSON.\n\n    Returns\n    -------\n    str\n        The JSON-serialized EncryptedManifest.\n    \"\"\"\n    start_nonce = os.urandom(32)\n    self.nonce_hasher.next_hash(start_nonce)\n    enc_manifest = self.encrypt_chunk(manifest.encode())\n    return EncryptedManifest(\n        type=\"enc_manifest\",\n        nonce=start_nonce.hex(),\n        hidden_manifest=enc_manifest.hex()\n    ).to_json()\n</code></pre>"},{"location":"api/#p2p_copy.security.ChainedChecksum","title":"ChainedChecksum","text":"<p>Generate chained SHA-256 checksums over sequential payloads.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>bytes</code> <p>Initial seed for the chain. Default is empty bytes.</p> <code>b''</code> Source code in <code>src/p2p_copy/security.py</code> <pre><code>class ChainedChecksum:\n    \"\"\"\n    Generate chained SHA-256 checksums over sequential payloads.\n\n    Parameters\n    ----------\n    seed : bytes, optional\n        Initial seed for the chain. Default is empty bytes.\n    \"\"\"\n\n    def __init__(self, seed: bytes = b\"\") -&gt; None:\n        self.prev_chain = seed\n\n    def next_hash(self, payload: bytes = b\"\") -&gt; bytes:\n        \"\"\"\n        Compute the next hash in the chain: sha256(prev_chain || payload).\n\n        Parameters\n        ----------\n        payload : bytes, optional\n            Data to include in this hash. Default is empty.\n\n        Returns\n        -------\n        bytes\n            The 32-byte hash, which becomes the new prev_chain.\n        \"\"\"\n        h = hashlib.sha256()\n        h.update(self.prev_chain)\n        h.update(payload)\n        self.prev_chain = h.digest()\n        return self.prev_chain\n</code></pre>"},{"location":"api/#p2p_copy.security.ChainedChecksum.next_hash","title":"next_hash","text":"<pre><code>next_hash(payload=b'')\n</code></pre> <p>Compute the next hash in the chain: sha256(prev_chain || payload).</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>bytes</code> <p>Data to include in this hash. Default is empty.</p> <code>b''</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The 32-byte hash, which becomes the new prev_chain.</p> Source code in <code>src/p2p_copy/security.py</code> <pre><code>def next_hash(self, payload: bytes = b\"\") -&gt; bytes:\n    \"\"\"\n    Compute the next hash in the chain: sha256(prev_chain || payload).\n\n    Parameters\n    ----------\n    payload : bytes, optional\n        Data to include in this hash. Default is empty.\n\n    Returns\n    -------\n    bytes\n        The 32-byte hash, which becomes the new prev_chain.\n    \"\"\"\n    h = hashlib.sha256()\n    h.update(self.prev_chain)\n    h.update(payload)\n    self.prev_chain = h.digest()\n    return self.prev_chain\n</code></pre>"},{"location":"api/#p2p_copy.security.import_optional_security_libs","title":"import_optional_security_libs","text":"<pre><code>import_optional_security_libs()\n</code></pre> <p>Import optional security libraries (argon2-cffi, cryptography) if encryption is used.</p> Source code in <code>src/p2p_copy/security.py</code> <pre><code>def import_optional_security_libs():\n    \"\"\"\n    Import optional security libraries (argon2-cffi, cryptography) if encryption is used.\n    \"\"\"\n    global hash_secret_raw, Type, AESGCM\n    try:\n        # security libs are needed if encryption is used\n        from argon2.low_level import hash_secret_raw, Type\n        from cryptography.hazmat.primitives.ciphers.aead import AESGCM\n    except ModuleNotFoundError as E:\n        raise ModuleNotFoundError(\n            E.msg + '\\nTo use encryption optional security libs are needed (pip install \".[security]\")')\n</code></pre>"},{"location":"api/#p2p_copy.compressor","title":"compressor","text":""},{"location":"api/#p2p_copy.compressor.CompressMode","title":"CompressMode","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of compression modes.</p> Source code in <code>src/p2p_copy/compressor.py</code> <pre><code>class CompressMode(str, Enum):\n    \"\"\"\n    Enumeration of compression modes.\n    \"\"\"\n\n    auto = \"auto\"\n    on = \"on\"\n    off = \"off\"\n</code></pre>"},{"location":"api/#p2p_copy.compressor.Compressor","title":"Compressor","text":"<p>Handle compression and decompression of chunks using Zstandard.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>CompressMode</code> <p>Compression mode. Default is 'auto'.</p> <code>auto</code> Source code in <code>src/p2p_copy/compressor.py</code> <pre><code>class Compressor:\n    \"\"\"\n    Handle compression and decompression of chunks using Zstandard.\n\n    Parameters\n    ----------\n    mode : CompressMode, optional\n        Compression mode. Default is 'auto'.\n    \"\"\"\n\n    def __init__(self, mode: CompressMode = CompressMode.auto):\n        self.mode = mode\n        self.cctx: Optional[zstd.ZstdCompressor] = zstd.ZstdCompressor(level=3) if mode != CompressMode.off else None\n        self.dctx: Optional[zstd.ZstdDecompressor] = None\n        self.use_compression: bool = mode == CompressMode.on\n        self.compression_type: str = \"zstd\" if mode == CompressMode.on else \"none\"\n\n    async def determine_compression(self, first_chunk: bytes) -&gt; bytes:\n        \"\"\"\n        Determine if compression should be used based on the first chunk (auto mode).\n\n        Parameters\n        ----------\n        first_chunk : bytes\n            The first chunk of data.\n\n        Returns\n        -------\n        bytes\n            The (possibly compressed) first chunk.\n        \"\"\"\n\n        if self.mode == CompressMode.off:\n            return first_chunk\n\n        else:\n            compressed = self.cctx.compress(first_chunk)\n            if self.mode == CompressMode.on:\n                return compressed\n\n            elif self.mode == CompressMode.auto:\n                # Auto mode: test first chunk\n                compression_ratio = len(compressed) / len(first_chunk) if first_chunk else 1.0\n                self.use_compression = compression_ratio &lt; 0.95  # Enable if compressed size &lt; 95% of original\n                self.compression_type = \"zstd\" if self.use_compression else \"none\"\n                return compressed if self.use_compression else first_chunk\n\n    def compress(self, chunk: bytes) -&gt; bytes:\n        \"\"\"\n        Compress a chunk if compression is enabled.\n\n        Parameters\n        ----------\n        chunk : bytes\n            The chunk to compress.\n\n        Returns\n        -------\n        bytes\n            The compressed or original chunk.\n        \"\"\"\n        \"\"\"Compress a chunk if compression is enabled.\"\"\"\n        if self.use_compression and self.cctx:\n            return self.cctx.compress(chunk)\n        return chunk\n\n    def decompress(self, chunk: bytes) -&gt; bytes:\n        \"\"\"\n        Decompress a chunk if decompression is set up.\n\n        Parameters\n        ----------\n        chunk : bytes\n            The chunk to decompress.\n\n        Returns\n        -------\n        bytes\n            The decompressed or original chunk.\n        \"\"\"\n\n        if self.dctx:\n            return self.dctx.decompress(chunk)\n        return chunk\n\n    def set_decompression(self, compression_type: str):\n        \"\"\"\n        Set up the decompressor based on the compression type.\n\n        Parameters\n        ----------\n        compression_type : str\n            The type of compression ('zstd' or 'none').\n        \"\"\"\n\n        self.dctx = zstd.ZstdDecompressor() if compression_type == \"zstd\" else None\n</code></pre>"},{"location":"api/#p2p_copy.compressor.Compressor.determine_compression","title":"determine_compression  <code>async</code>","text":"<pre><code>determine_compression(first_chunk)\n</code></pre> <p>Determine if compression should be used based on the first chunk (auto mode).</p> <p>Parameters:</p> Name Type Description Default <code>first_chunk</code> <code>bytes</code> <p>The first chunk of data.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The (possibly compressed) first chunk.</p> Source code in <code>src/p2p_copy/compressor.py</code> <pre><code>async def determine_compression(self, first_chunk: bytes) -&gt; bytes:\n    \"\"\"\n    Determine if compression should be used based on the first chunk (auto mode).\n\n    Parameters\n    ----------\n    first_chunk : bytes\n        The first chunk of data.\n\n    Returns\n    -------\n    bytes\n        The (possibly compressed) first chunk.\n    \"\"\"\n\n    if self.mode == CompressMode.off:\n        return first_chunk\n\n    else:\n        compressed = self.cctx.compress(first_chunk)\n        if self.mode == CompressMode.on:\n            return compressed\n\n        elif self.mode == CompressMode.auto:\n            # Auto mode: test first chunk\n            compression_ratio = len(compressed) / len(first_chunk) if first_chunk else 1.0\n            self.use_compression = compression_ratio &lt; 0.95  # Enable if compressed size &lt; 95% of original\n            self.compression_type = \"zstd\" if self.use_compression else \"none\"\n            return compressed if self.use_compression else first_chunk\n</code></pre>"},{"location":"api/#p2p_copy.compressor.Compressor.compress","title":"compress","text":"<pre><code>compress(chunk)\n</code></pre> <p>Compress a chunk if compression is enabled.</p> <p>Parameters:</p> Name Type Description Default <code>chunk</code> <code>bytes</code> <p>The chunk to compress.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The compressed or original chunk.</p> Source code in <code>src/p2p_copy/compressor.py</code> <pre><code>def compress(self, chunk: bytes) -&gt; bytes:\n    \"\"\"\n    Compress a chunk if compression is enabled.\n\n    Parameters\n    ----------\n    chunk : bytes\n        The chunk to compress.\n\n    Returns\n    -------\n    bytes\n        The compressed or original chunk.\n    \"\"\"\n    \"\"\"Compress a chunk if compression is enabled.\"\"\"\n    if self.use_compression and self.cctx:\n        return self.cctx.compress(chunk)\n    return chunk\n</code></pre>"},{"location":"api/#p2p_copy.compressor.Compressor.decompress","title":"decompress","text":"<pre><code>decompress(chunk)\n</code></pre> <p>Decompress a chunk if decompression is set up.</p> <p>Parameters:</p> Name Type Description Default <code>chunk</code> <code>bytes</code> <p>The chunk to decompress.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The decompressed or original chunk.</p> Source code in <code>src/p2p_copy/compressor.py</code> <pre><code>def decompress(self, chunk: bytes) -&gt; bytes:\n    \"\"\"\n    Decompress a chunk if decompression is set up.\n\n    Parameters\n    ----------\n    chunk : bytes\n        The chunk to decompress.\n\n    Returns\n    -------\n    bytes\n        The decompressed or original chunk.\n    \"\"\"\n\n    if self.dctx:\n        return self.dctx.decompress(chunk)\n    return chunk\n</code></pre>"},{"location":"api/#p2p_copy.compressor.Compressor.set_decompression","title":"set_decompression","text":"<pre><code>set_decompression(compression_type)\n</code></pre> <p>Set up the decompressor based on the compression type.</p> <p>Parameters:</p> Name Type Description Default <code>compression_type</code> <code>str</code> <p>The type of compression ('zstd' or 'none').</p> required Source code in <code>src/p2p_copy/compressor.py</code> <pre><code>def set_decompression(self, compression_type: str):\n    \"\"\"\n    Set up the decompressor based on the compression type.\n\n    Parameters\n    ----------\n    compression_type : str\n        The type of compression ('zstd' or 'none').\n    \"\"\"\n\n    self.dctx = zstd.ZstdDecompressor() if compression_type == \"zstd\" else None\n</code></pre>"},{"location":"api/#p2p_copy.protocol","title":"protocol","text":""},{"location":"api/#p2p_copy.protocol.Hello","title":"Hello  <code>dataclass</code>","text":"<p>Hello message for connection initiation.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Literal['hello']</code> <p>Message type.</p> required <code>code_hash_hex</code> <code>str</code> <p>Hex-encoded hash of the shared code.</p> required <code>role</code> <code>Literal['sender', 'receiver']</code> <p>The role of this client.</p> required Source code in <code>src/p2p_copy/protocol.py</code> <pre><code>@dataclass(frozen=True)\nclass Hello:\n    \"\"\"\n    Hello message for connection initiation.\n\n    Parameters\n    ----------\n    type : Literal[\"hello\"]\n        Message type.\n    code_hash_hex : str\n        Hex-encoded hash of the shared code.\n    role : Literal[\"sender\", \"receiver\"]\n        The role of this client.\n    \"\"\"\n    type: Literal[\"hello\"]\n    code_hash_hex: str\n    role: Literal[\"sender\", \"receiver\"]\n\n    def to_json(self) -&gt; str:\n        return dumps({\"type\": \"hello\", \"code_hash_hex\": self.code_hash_hex, \"role\": self.role})\n</code></pre>"},{"location":"api/#p2p_copy.protocol.ManifestEntry","title":"ManifestEntry  <code>dataclass</code>","text":"<p>Entry in a file manifest.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Relative path of the file.</p> required <code>size</code> <code>int</code> <p>File size in bytes.</p> required Source code in <code>src/p2p_copy/protocol.py</code> <pre><code>@dataclass(frozen=True)\nclass ManifestEntry:\n    \"\"\"\n    Entry in a file manifest.\n\n    Parameters\n    ----------\n    path : str\n        Relative path of the file.\n    size : int\n        File size in bytes.\n    \"\"\"\n    path: str\n    size: int\n</code></pre>"},{"location":"api/#p2p_copy.protocol.Manifest","title":"Manifest  <code>dataclass</code>","text":"<p>Manifest of files to send.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Literal['manifest']</code> <p>Message type.</p> required <code>entries</code> <code>Sequence[ManifestEntry]</code> <p>List of file entries.</p> required <code>resume</code> <code>bool</code> <p>Whether to enable resume. Default is False.</p> <code>False</code> Source code in <code>src/p2p_copy/protocol.py</code> <pre><code>@dataclass(frozen=True)\nclass Manifest:\n    \"\"\"\n    Manifest of files to send.\n\n    Parameters\n    ----------\n    type : Literal[\"manifest\"]\n        Message type.\n    entries : Sequence[ManifestEntry]\n        List of file entries.\n    resume : bool, optional\n        Whether to enable resume. Default is False.\n    \"\"\"\n    type: Literal[\"manifest\"]\n    entries: Sequence[ManifestEntry]\n    resume: bool = False\n\n    def to_json(self) -&gt; str:\n        return dumps({\n            \"type\": \"manifest\",\n            \"resume\": self.resume,\n            \"entries\": [asdict(e) for e in self.entries]\n        })\n</code></pre>"},{"location":"api/#p2p_copy.protocol.EncryptedManifest","title":"EncryptedManifest  <code>dataclass</code>","text":"<p>Encrypted manifest for secure transmission.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Literal['enc_manifest']</code> <p>Message type.</p> required <code>nonce</code> <code>str</code> <p>Hex-encoded nonce that is used as random seed. Further nonces are based on this and used for encryption. Must be shared with receiver so it can decrypt accordingly.</p> required <code>hidden_manifest</code> <code>str</code> <p>Hex-encoded encrypted manifest.</p> required Source code in <code>src/p2p_copy/protocol.py</code> <pre><code>@dataclass(frozen=True)\nclass EncryptedManifest:\n    \"\"\"\n    Encrypted manifest for secure transmission.\n\n    Parameters\n    ----------\n    type : Literal[\"enc_manifest\"]\n        Message type.\n    nonce : str\n        Hex-encoded nonce that is used as random seed.\n        Further nonces are based on this and used for encryption.\n        Must be shared with receiver so it can decrypt accordingly.\n    hidden_manifest : str\n        Hex-encoded encrypted manifest.\n    \"\"\"\n    type: Literal[\"enc_manifest\"]\n    nonce: str\n    hidden_manifest: str\n\n    def to_json(self) -&gt; str:\n        return dumps({\n            \"type\": \"enc_manifest\",\n            \"nonce\": self.nonce,\n            \"hidden_manifest\": self.hidden_manifest\n        })\n</code></pre>"},{"location":"api/#p2p_copy.protocol.ReceiverManifestEntry","title":"ReceiverManifestEntry  <code>dataclass</code>","text":"<p>Receiver's report of existing file state for resume.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Relative path.</p> required <code>size</code> <code>int</code> <p>Bytes already present.</p> required <code>chain_hex</code> <code>str</code> <p>Hex-encoded chained checksum up to 'size'.</p> required Source code in <code>src/p2p_copy/protocol.py</code> <pre><code>@dataclass(frozen=True)\nclass ReceiverManifestEntry:\n    \"\"\"\n    Receiver's report of existing file state for resume.\n\n    Parameters\n    ----------\n    path : str\n        Relative path.\n    size : int\n        Bytes already present.\n    chain_hex : str\n        Hex-encoded chained checksum up to 'size'.\n    \"\"\"\n    path: str\n    size: int\n    chain_hex: str\n</code></pre>"},{"location":"api/#p2p_copy.protocol.ReceiverManifest","title":"ReceiverManifest  <code>dataclass</code>","text":"<p>Manifest from receiver reporting existing files.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Literal['receiver_manifest']</code> <p>Message type.</p> required <code>entries</code> <code>Sequence[ReceiverManifestEntry]</code> <p>List of entries.</p> required Source code in <code>src/p2p_copy/protocol.py</code> <pre><code>@dataclass(frozen=True)\nclass ReceiverManifest:\n    \"\"\"\n    Manifest from receiver reporting existing files.\n\n    Parameters\n    ----------\n    type : Literal[\"receiver_manifest\"]\n        Message type.\n    entries : Sequence[ReceiverManifestEntry]\n        List of entries.\n    \"\"\"\n    type: Literal[\"receiver_manifest\"]\n    entries: Sequence[ReceiverManifestEntry]\n\n    def to_json(self) -&gt; str:\n        return dumps({\n            \"type\": \"receiver_manifest\",\n            \"entries\": [asdict(e) for e in self.entries]\n        })\n</code></pre>"},{"location":"api/#p2p_copy.protocol.EncryptedReceiverManifest","title":"EncryptedReceiverManifest  <code>dataclass</code>","text":"<p>Encrypted receiver manifest.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Literal['enc_receiver_manifest']</code> <p>Message type.</p> required <code>hidden_manifest</code> <code>str</code> <p>Hex-encoded encrypted manifest.</p> required Source code in <code>src/p2p_copy/protocol.py</code> <pre><code>@dataclass(frozen=True)\nclass EncryptedReceiverManifest:\n    \"\"\"\n    Encrypted receiver manifest.\n\n    Parameters\n    ----------\n    type : Literal[\"enc_receiver_manifest\"]\n        Message type.\n    hidden_manifest : str\n        Hex-encoded encrypted manifest.\n    \"\"\"\n    type: Literal[\"enc_receiver_manifest\"]\n    hidden_manifest: str\n\n    def to_json(self) -&gt; str:\n        return dumps({\n            \"type\": \"enc_receiver_manifest\",\n            \"hidden_manifest\": self.hidden_manifest\n        })\n</code></pre>"},{"location":"api/#p2p_copy.protocol.dumps","title":"dumps","text":"<pre><code>dumps(msg)\n</code></pre> <p>JSON-dump a message with compact separators.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>Dict[str, Any]</code> <p>The message to serialize.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Compact JSON string.</p> Source code in <code>src/p2p_copy/protocol.py</code> <pre><code>def dumps(msg: Dict[str, Any]) -&gt; str:\n    \"\"\"\n    JSON-dump a message with compact separators.\n\n    Parameters\n    ----------\n    msg : Dict[str, Any]\n        The message to serialize.\n\n    Returns\n    -------\n    str\n        Compact JSON string.\n    \"\"\"\n    return json.dumps(msg, separators=(\",\", \":\"), ensure_ascii=False)\n</code></pre>"},{"location":"api/#p2p_copy.protocol.loads","title":"loads","text":"<pre><code>loads(s)\n</code></pre> <p>JSON-load a string into a dict.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>JSON string.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Parsed dictionary.</p> Source code in <code>src/p2p_copy/protocol.py</code> <pre><code>def loads(s: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    JSON-load a string into a dict.\n\n    Parameters\n    ----------\n    s : str\n        JSON string.\n\n    Returns\n    -------\n    Dict[str, Any]\n        Parsed dictionary.\n    \"\"\"\n    return json.loads(s)\n</code></pre>"},{"location":"api/#p2p_copy.protocol.file_begin","title":"file_begin","text":"<pre><code>file_begin(path, size, compression='none', append_from=0)\n</code></pre> <p>Create a file begin control message.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Relative path.</p> required <code>size</code> <code>int</code> <p>Total file size.</p> required <code>compression</code> <code>str</code> <p>Compression type. Default is 'none'.</p> <code>'none'</code> <code>append_from</code> <code>int</code> <p>Byte offset to append from. Default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>JSON string of the message.</p> Source code in <code>src/p2p_copy/protocol.py</code> <pre><code>def file_begin(path: str, size: int, compression: str = \"none\", append_from: int = 0) -&gt; str:\n    \"\"\"\n    Create a file begin control message.\n\n    Parameters\n    ----------\n    path : str\n        Relative path.\n    size : int\n        Total file size.\n    compression : str, optional\n        Compression type. Default is 'none'.\n    append_from : int, optional\n        Byte offset to append from. Default is 0.\n\n    Returns\n    -------\n    str\n        JSON string of the message.\n    \"\"\"\n    \"\"\"\n    Start of a file stream. If append_from is given, it indicates the sender will\n    only send bytes from [append_from .. size) and the receiver should open in 'ab'.\n    \"\"\"\n    msg: Dict[str, Any] = {\n        \"type\": \"file\",\n        \"path\": path,\n        \"size\": int(size),\n        \"compression\": compression,\n        \"append_from\": append_from\n    }\n\n    return dumps(msg)\n</code></pre>"},{"location":"api/#p2p_copy.protocol.encrypted_file_begin","title":"encrypted_file_begin","text":"<pre><code>encrypted_file_begin(hidden_file_info)\n</code></pre> <p>Wrap encrypted file info in a control message.</p> <p>Parameters:</p> Name Type Description Default <code>hidden_file_info</code> <code>bytes</code> <p>Encrypted file begin data.</p> required <p>Returns:</p> Type Description <code>str</code> <p>JSON string of the enc_file message.</p> Source code in <code>src/p2p_copy/protocol.py</code> <pre><code>def encrypted_file_begin(hidden_file_info: bytes) -&gt; str:\n    \"\"\"\n    Wrap encrypted file info in a control message.\n\n    Parameters\n    ----------\n    hidden_file_info : bytes\n        Encrypted file begin data.\n\n    Returns\n    -------\n    str\n        JSON string of the enc_file message.\n    \"\"\"\n    payload = {\n        \"type\": \"enc_file\",\n        \"hidden_file\": hidden_file_info.hex()\n    }\n    return dumps(payload)\n</code></pre>"},{"location":"api/#p2p_copy.protocol.pack_chunk","title":"pack_chunk","text":"<pre><code>pack_chunk(seq, chain, payload)\n</code></pre> <p>Pack a chunk into a binary frame.</p> <p>Parameters:</p> Name Type Description Default <code>seq</code> <code>int</code> <p>Sequence number.</p> required <code>chain</code> <code>bytes</code> <p>32-byte chain checksum.</p> required <code>payload</code> <code>bytes</code> <p>The data payload.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Packed frame.</p> Source code in <code>src/p2p_copy/protocol.py</code> <pre><code>def pack_chunk(seq: int, chain: bytes, payload: bytes) -&gt; bytes:\n    \"\"\"\n    Pack a chunk into a binary frame.\n\n    Parameters\n    ----------\n    seq : int\n        Sequence number.\n    chain : bytes\n        32-byte chain checksum.\n    payload : bytes\n        The data payload.\n\n    Returns\n    -------\n    bytes\n        Packed frame.\n    \"\"\"\n    return CHUNK_HEADER.pack(seq, chain) + payload\n</code></pre>"},{"location":"api/#p2p_copy.protocol.unpack_chunk","title":"unpack_chunk","text":"<pre><code>unpack_chunk(frame)\n</code></pre> <p>Unpack a binary chunk frame.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>bytes</code> <p>The binary frame.</p> required <p>Returns:</p> Type Description <code>Tuple[int, bytes, bytes]</code> <p>(seq, chain, payload)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If frame is too short.</p> Source code in <code>src/p2p_copy/protocol.py</code> <pre><code>def unpack_chunk(frame: bytes) -&gt; Tuple[int, bytes, bytes]:\n    \"\"\"\n    Unpack a binary chunk frame.\n\n    Parameters\n    ----------\n    frame : bytes\n        The binary frame.\n\n    Returns\n    -------\n    Tuple[int, bytes, bytes]\n        (seq, chain, payload)\n\n    Raises\n    ------\n    ValueError\n        If frame is too short.\n    \"\"\"\n    if len(frame) &lt; CHUNK_HEADER.size:\n        raise ValueError(\"short chunk frame\")\n    seq, chain = CHUNK_HEADER.unpack(frame[:CHUNK_HEADER.size])\n    payload = frame[CHUNK_HEADER.size:]\n    return seq, chain, payload\n</code></pre>"},{"location":"api/#p2p_copy.io_utils","title":"io_utils","text":""},{"location":"api/#p2p_copy.io_utils.read_in_chunks","title":"read_in_chunks  <code>async</code>","text":"<pre><code>read_in_chunks(fp, *, chunk_size=CHUNK_SIZE)\n</code></pre> <p>Asynchronously read bytes from a file in chunks.</p> <p>Parameters:</p> Name Type Description Default <code>fp</code> <code>BinaryIO</code> <p>The file pointer to read from.</p> required <code>chunk_size</code> <code>int</code> <p>Size of each chunk in bytes. Default is 1 MiB.</p> <code>CHUNK_SIZE</code> <p>Yields:</p> Type Description <code>bytes</code> <p>The next chunk of data.</p> Source code in <code>src/p2p_copy/io_utils.py</code> <pre><code>async def read_in_chunks(fp: BinaryIO, *, chunk_size: int = CHUNK_SIZE) -&gt; AsyncIterable[bytes]:\n    \"\"\"\n    Asynchronously read bytes from a file in chunks.\n\n    Parameters\n    ----------\n    fp : BinaryIO\n        The file pointer to read from.\n    chunk_size : int, optional\n        Size of each chunk in bytes. Default is 1 MiB.\n\n    Yields\n    ------\n    bytes\n        The next chunk of data.\n    \"\"\"\n\n    while True:\n        # Read from disk without blocking the event-loop\n        chunk = await asyncio.to_thread(fp.read, chunk_size)\n        if not chunk:\n            break\n        yield chunk\n</code></pre>"},{"location":"api/#p2p_copy.io_utils.compute_chain_up_to","title":"compute_chain_up_to  <code>async</code>","text":"<pre><code>compute_chain_up_to(path, limit=None)\n</code></pre> <p>Compute chained checksum over the raw bytes of a file up to a limit.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the file.</p> required <code>limit</code> <code>int</code> <p>Maximum bytes to hash. If None, hash the entire file.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[int, bytes]</code> <p>(bytes_hashed, final_chain_bytes)</p> Source code in <code>src/p2p_copy/io_utils.py</code> <pre><code>async def compute_chain_up_to(path: Path, limit: int | None = None) -&gt; Tuple[int, bytes]:\n    \"\"\"\n    Compute chained checksum over the raw bytes of a file up to a limit.\n\n    Parameters\n    ----------\n    path : Path\n        Path to the file.\n    limit : int, optional\n        Maximum bytes to hash. If None, hash the entire file.\n\n    Returns\n    -------\n    tuple[int, bytes]\n        (bytes_hashed, final_chain_bytes)\n    \"\"\"\n\n    c = ChainedChecksum()\n    hashed = 0\n    with path.open(\"rb\") as fp:\n        if limit is None:\n            while True:\n                chunk = await asyncio.to_thread(fp.read, CHUNK_SIZE)\n                if not chunk:\n                    break\n                hashed += len(chunk)\n                c.next_hash(chunk)\n        else:\n            remaining = int(limit)\n            while remaining &gt; 0:\n                to_read = min(remaining, CHUNK_SIZE)\n                chunk = await asyncio.to_thread(fp.read, to_read)\n                if not chunk:\n                    break\n                hashed += len(chunk)\n                remaining -= len(chunk)\n                c.next_hash(chunk)\n    return hashed, c.prev_chain\n</code></pre>"},{"location":"api/#p2p_copy.io_utils.iter_manifest_entries","title":"iter_manifest_entries","text":"<pre><code>iter_manifest_entries(paths)\n</code></pre> <p>Yield manifest entries for files in the given paths (files or directories).</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>List[str]</code> <p>List of file or directory paths.</p> required <p>Yields:</p> Type Description <code>Tuple[Path, Path, int]</code> <p>(absolute_path, relative_path, size)</p> Notes <ul> <li>Yields files in sorted order for directories.</li> <li>Skips non-existent or invalid paths.</li> </ul> Source code in <code>src/p2p_copy/io_utils.py</code> <pre><code>def iter_manifest_entries(paths: List[str]) -&gt; Iterator[Tuple[Path, Path, int]]:\n    \"\"\"\n    Yield manifest entries for files in the given paths (files or directories).\n\n    Parameters\n    ----------\n    paths : List[str]\n        List of file or directory paths.\n\n    Yields\n    ------\n    Tuple[Path, Path, int]\n        (absolute_path, relative_path, size)\n\n    Notes\n    -----\n    - Yields files in sorted order for directories.\n    - Skips non-existent or invalid paths.\n    \"\"\"\n\n    if not isinstance(paths, list):\n        print(\"[p2p_copy] send(): files or dirs must be passed as list\")\n        return\n    elif not paths:\n        return\n\n    for raw in paths:\n        if len(raw) == 1:\n            print(\"[p2p_copy] send(): probably not a file:\", raw)\n            continue\n        p = Path(raw).expanduser()\n        if not p.exists():\n            print(\"[p2p_copy] send(): file does not exist:\", p)\n            continue\n        if p.is_file():\n            yield p.resolve(), Path(p.name), p.stat().st_size\n        else:\n            root = p.resolve()\n            for sub in sorted(root.rglob(\"*\")):\n                if sub.is_file():\n                    rel = Path(p.name) / sub.relative_to(root)\n                    yield sub.resolve(), rel, sub.stat().st_size\n</code></pre>"},{"location":"api/#p2p_copy.io_utils.ensure_dir","title":"ensure_dir","text":"<pre><code>ensure_dir(p)\n</code></pre> <p>Ensure the directory exists, creating parents if needed.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>Path</code> <p>The path to ensure is a directory.</p> required Source code in <code>src/p2p_copy/io_utils.py</code> <pre><code>def ensure_dir(p: Path) -&gt; None:\n    \"\"\"\n    Ensure the directory exists, creating parents if needed.\n\n    Parameters\n    ----------\n    p : Path\n        The path to ensure is a directory.\n    \"\"\"\n    p.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"api/#p2p_copy_server","title":"p2p_copy_server","text":""},{"location":"api/#p2p_copy_server.run_relay","title":"run_relay  <code>async</code>","text":"<pre><code>run_relay(host, port, use_tls=True, certfile=None, keyfile=None)\n</code></pre> <p>Run the WebSocket relay server, optionally with TLS.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host to bind to.</p> required <code>port</code> <code>int</code> <p>Port to bind to.</p> required <code>use_tls</code> <code>bool</code> <p>Whether to use TLS. Default is True.</p> <code>True</code> <code>certfile</code> <code>str</code> <p>Path to TLS certificate file.</p> <code>None</code> <code>keyfile</code> <code>str</code> <p>Path to TLS key file.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If TLS is requested but certfile or keyfile is missing.</p> Source code in <code>src/p2p_copy_server/relay.py</code> <pre><code>async def run_relay(host: str, port: int,\n                    use_tls: bool = True,\n                    certfile: Optional[str] = None,\n                    keyfile: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Run the WebSocket relay server, optionally with TLS.\n\n    Parameters\n    ----------\n    host : str\n        Host to bind to.\n    port : int\n        Port to bind to.\n    use_tls : bool, optional\n        Whether to use TLS. Default is True.\n    certfile : str, optional\n        Path to TLS certificate file.\n    keyfile : str, optional\n        Path to TLS key file.\n\n    Raises\n    ------\n    RuntimeError\n        If TLS is requested but certfile or keyfile is missing.\n    \"\"\"\n    ssl_ctx = None\n    if use_tls:\n        if not certfile or not keyfile:\n            raise RuntimeError(\"TLS requested but certfile/keyfile missing\")\n        ssl_ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        ssl_ctx.load_cert_chain(certfile, keyfile)\n\n    scheme = \"wss\" if ssl_ctx else \"ws\"\n    print(f\"\\nRelay listening on {scheme}://{host}:{port}\")\n\n    if host != \"localhost\":\n        use_production_logger()\n\n    async with serve(_handle, host, port, max_size=2**21, ssl=ssl_ctx, compression=None):\n        await asyncio.Future()  # run forever\n</code></pre>"},{"location":"examples/","title":"APIExamples","text":"<p>Note: Complete examples in python files can be found in /examples. Tests can be found in /test. </p> <pre><code># import the needed functions from the api, maybe alias them\nfrom p2p_copy import send as api_send, receive as api_receive\nfrom p2p_copy_server import run_relay\nimported_functions = api_send, api_receive, run_relay\n\n# alternatively just import the modules and refer accordingly\nimport p2p_copy, p2p_copy_server\nimported_module_functions = p2p_copy.send, p2p_copy.receive, p2p_copy_server.run_relay\n\nassert imported_functions == imported_module_functions, \"Error: functions are different\"\n\n</code></pre> <pre><code># asyncio is used to run code asynchronously in an event-loop\nimport asyncio\nfrom p2p_copy_server import run_relay\n\ndef usage_of_relay():\n    # To copy over a network listen on all interfaces on port 443\n    # This might require elevated privileges\n    host, port = \"0.0.0.0\", 443\n    # For local tests use this\n    host, port = \"localhost\", 8765\n\n\n    # Start the relay. It runs in a coroutine\n    # host and port are always required\n    # If TLS is used (which is the default) TLS cert- and keyfile are also required\n    \"\"\"\n    relay_coroutine = run_relay(host=host, port=port, use_tls=True,\n        certfile=\"/etc/letsencrypt/live/relay.example.org/fullchain.pem\",\n        keyfile=\"/etc/letsencrypt/live/relay.example.org/privkey.pem\")\n    \"\"\"\n\n    # For local tests instead, no TLS needs to be used\n    relay_coroutine = run_relay(host=host, port=port, use_tls=False)\n\n    # If the relay should not run forever, add a timeout\n    relay_coroutine_with_timeout = asyncio.wait_for(relay_coroutine, timeout=20)\n    return relay_coroutine_with_timeout\n\n</code></pre> <pre><code>import asyncio\nfrom pathlib import Path\n# Import the needed functions from the api, maybe alias them\nfrom p2p_copy import receive as api_receive\n\ndef usage_of_receive():\n    # If TLS is used the protocol/url-prefix changes from ws to wss\n    # To copy over a Server use\n    host, port = \"relay.example.org\", 443\n    server_url = f\"wss://{host}:{port}\"\n\n    # For local tests use\n    host, port = \"localhost\", 8765\n    server_url = f\"ws://{host}:{port}\"\n\n    # A shared code that will be used as passphrase\n    # It must only be known by trusted peers\n    code = \"demoCode123\"\n\n    # Optionally End-to-End encryption can be enabled if set to True\n    # Sender and receiver need to use the same settings\n    encrypt = True\n\n    # Define a directory to store received files in\n    # Else they end up in the current directory\n    out_dir = Path(\"downloads\")\n\n    # Start receiving in coroutine\n    # Awaiting the coroutine returns the return code\n    # Any nonzero return code indicates an error\n    receive_coroutine = api_receive(server=server_url, code=code, encrypt=encrypt, out=str(out_dir))\n    return receive_coroutine\n\n</code></pre> <pre><code>import asyncio\nimport time\nfrom pathlib import Path\n\n# Import the needed functions from the api, maybe alias them\nfrom p2p_copy import send as api_send\n\ndef usage_of_send():\n    # If TLS is used the protocol/url-prefix changes from ws to wss\n    # To copy over a Server use\n    host, port = \"relay.example.org\", 443\n    server_url = f\"wss://{host}:{port}\"\n\n    host, port = \"localhost\", 8765\n    server_url = f\"ws://{host}:{port}\"\n\n    # A shared code that will be used as passphrase\n    # It must only be known by trusted peers\n    code = \"demoCode123\"\n\n    # Optionally End-to-End encryption can be enabled if set to True\n    # Sender and receiver need to use the same settings\n    encrypt = True\n\n    # The send function will automatically decide whether files should be compressed\n    # Optionally compression can be manually set to \"on\", \"off\" or \"auto\"\n    compress = \"on\"\n    # For clarity the enum can be used\n    from p2p_copy import CompressMode\n    compress = CompressMode.on\n\n    # The resume keyword can be used to skip files or parts of files that already exist on the receiver side\n    # Else the send function will send each file in full and overwrite existing files with the same name\n    resume = True\n\n    # Create a test file to be sent\n    src = Path(\"sample.txt\")\n    src.write_text(\"sample text created: \" + time.ctime())\n\n    # Prepare a list of multiple paths\n    # Those can be files or directories that will be sent\n    paths = [str(src)]\n\n    # Start sending in a coroutine\n    # Awaiting the coroutine returns the return code\n    # Any nonzero return code indicates an error\n    send_coroutine = api_send(server=server_url, code=code, files=paths, encrypt=encrypt, compress=compress, resume=resume)\n    return send_coroutine\n\n</code></pre> <pre><code># asyncio is used to run code asynchronously in an event-loop\nimport asyncio\n\nasync def local_test():\n    \"\"\"\n    After running this a file should be copied into \"examples/downloads\"\n    The same can be done by running the *usage.py examples separately at the same time\n    \"\"\"\n\n    # Usage code examples need to either run on different machines or in different processes/tasks/threats\n    # Else awaiting one will block the others\n\n    # Step 1 Create a task that runs the relay in parallel\n    relay_task = asyncio.create_task(usage_of_relay())\n    await asyncio.sleep(0.1)  # give it a moment to bind\n\n    # Step 2 or 3 Create a task that runs the receiver in parallel\n    # After the relay was started\n    # Order between starting send or receive does not matter\n    recv_task = asyncio.create_task(usage_of_receive())\n\n    # Step 2 or 3 Create a task that runs the sender in parallel\n    send_task = asyncio.create_task(usage_of_send())\n\n    # Get the return codes\n    # This will block until both tasks are finished\n    return_code_receive = await recv_task\n    return_code_send = await send_task\n\n    # Alternatively avoid blocking for too long by interpreting as error after a timeout\n    try:\n        return_code_send = await asyncio.wait_for(send_task, timeout=10)\n    except asyncio.TimeoutError:\n        return_code_send = -1\n    try:\n        return_code_receive = await asyncio.wait_for(recv_task, timeout=1)\n    except asyncio.TimeoutError:\n        return_code_receive = -1\n\n    # Make sure no error codes had been returned\n    assert return_code_receive == 0 and return_code_send == 0, \"Returned with error code\"\n\n    # Step 4 cancel the relay task\n    try:\n        relay_task.cancel()\n        await relay_task\n    except asyncio.CancelledError:\n        pass\n\nif __name__ == \"__main__\":\n    # run the eventloop\n    asyncio.run(local_test())\n</code></pre>"},{"location":"features/","title":"Features","text":"<p>p2p-copy provides file transfer via WebSockets, pairing one sender and one receiver through a relay. It supports chunked streaming, optional encryption and compression, and resume. The CLI wraps a Python API for scripting. For usage, see Usage. For API, see API.</p>"},{"location":"features/#core-functionality","title":"Core Functionality","text":"<ul> <li>Firewall-Friendly: Uses WS/WSS over port 443 for outbound connections, bypassing inbound restrictions common in HPC environments.</li> <li>Pairing: Clients share a code (hashed with SHA-256 or Argon2 for encryption). Relay matches one sender and one receiver per hash.</li> <li>Chunked Streaming: Transfers in 1 MiB chunks without full-file buffering, reducing memory usage.</li> <li>Integrity Checks: Chained SHA-256 checksums detect corruption, loss, or reordering.</li> <li>Resume: Skips complete files and appends partial ones using checksums (receiver reports existing data).</li> <li>Manifest Exchange: Sender lists files; receiver responds with local states for resume.</li> </ul>"},{"location":"features/#optional-enhancements","title":"Optional Enhancements","text":"<ul> <li>End-to-End Encryption: AES-GCM with Argon2id-derived keys and chained nonces. Metadata and content encrypted; transport TLS separate. See Security.</li> <li>Compression: Zstandard (Zstd) per file. Modes: <code>auto</code> (tests first chunk for &lt;95% ratio), <code>on</code>, or <code>off</code>. Receiver auto-decompresses.</li> <li>Async I/O: Uses <code>asyncio</code> for non-blocking disk and network operations, maximizing throughput.</li> </ul>"},{"location":"features/#protocol-overview","title":"Protocol Overview","text":"<ul> <li>Handshake: JSON <code>hello</code> with role and code hash. Relay pairs and sends <code>ready</code> to sender.</li> <li>Controls: JSON frames for manifests, file starts (<code>file</code>/<code>enc_file</code>), and ends (<code>file_eof</code>, <code>eof</code>).</li> <li>Data Frames: Binary <code>[seq | chain | payload]</code>, with sequence and chained checksum.</li> <li>WebSocket Settings: Compression disabled to avoid interference.</li> </ul>"},{"location":"features/#resume-mechanism","title":"Resume Mechanism","text":"<ul> <li>Sender requests resume in manifest.</li> <li>Receiver computes chained checksums over raw bytes on disk.</li> <li>Sender validates prefixes: skips matches, appends partials, overwrites mismatches.</li> </ul>"},{"location":"features/#limitations","title":"Limitations","text":"<ul> <li>server performance limits the amount of concurrent transfers</li> <li>Single pair per code; no broadcasting.</li> <li>No relay storage; transfers depend on both clients to stay connected.</li> <li>Per-file (not per-chunk) compression decisions.</li> </ul>"},{"location":"features/#internals","title":"Internals","text":"<ul> <li>Framing in <code>protocol.py</code>.</li> <li>I/O in <code>io_utils.py</code> (e.g., async chunk reads).</li> <li>Compression in <code>compressor.py</code>.</li> <li>Security in <code>security.py</code>.</li> <li>Relay logic in <code>relay.py</code>.</li> </ul> <p>For module details, see Module Layout. For setup, see Relay Setup. For issues, see Troubleshooting.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher is required. Earlier versions may work but are not officially supported.</li> <li>This project contains additional optional features. Using an installation command without [...] will not install them.</li> </ul>"},{"location":"installation/#virtual-environment","title":"Virtual Environment","text":"<p>It is recommended to use a virtual environment for isolation:</p> <pre><code>python -m venv .venv\n</code></pre> <p>Activate the venv before installation and before use.</p> <pre><code>source .venv/bin/activate  # On Unix-like systems\n# Or on Windows: .venv\\Scripts\\activate\n</code></pre>"},{"location":"installation/#install-from-pypi","title":"Install from PyPI","text":"<p>For basic functionality:</p> <pre><code>pip install p2p-copy\n</code></pre> <p>With encryption support:</p> <pre><code>pip install \"p2p-copy[security]\"\n</code></pre> <p>This installs dependencies like <code>argon2-cffi</code> and <code>cryptography</code> for security features. See Security for details.</p>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>Clone the repository and install in editable mode:</p> <pre><code>git clone https://github.com/AfuLD/p2p-copy.git\ncd p2p-copy\npip install -e \".[dev,security]\"\n</code></pre> <p>This includes tools for testing (e.g., pytest) and documentation (e.g., MkDocs).</p>"},{"location":"installation/#relay-server-dependencies","title":"Relay Server Dependencies","text":"<p>The relay server requires no additional packages beyond the base installation. For TLS support, obtain certificates (e.g., via Let's Encrypt). See Relay Setup for configuration.</p> <p>For usage after installation, see Usage. If issues arise, consult Troubleshooting.</p>"},{"location":"layout/","title":"Module Layout","text":"<p>This page outlines the package structure and key modules of <code>p2p_copy</code>. The project uses a src-layout for packaging. For API details, see API.</p>"},{"location":"layout/#project-structure","title":"Project Structure","text":"<pre><code>p2p-copy/                      # Root\n\u251c\u2500\u2500 src/                       # Installable packages\n\u2502   \u251c\u2500\u2500 p2p_copy/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py        # Package init, re-exports public API\n\u2502   \u2502   \u251c\u2500\u2500 api.py             # Core async functions: send(), receive()\n\u2502   \u2502   \u251c\u2500\u2500 compressor.py      # Compression handling (Zstd)\n\u2502   \u2502   \u251c\u2500\u2500 io_utils.py        # File I/O, manifest iteration, checksums\n\u2502   \u2502   \u251c\u2500\u2500 protocol.py        # Data classes, framing, control messages\n\u2502   \u2502   \u2514\u2500\u2500 security.py        # Encryption (AES-GCM), hashing (Argon2)\n\u2502   \u251c\u2500\u2500 p2p_copy_cli/\n\u2502   \u2502   \u2514\u2500\u2500 main.py            # Typer CLI app (send, receive, run-relay-server)\n\u2502   \u2514\u2500\u2500 p2p_copy_server/\n\u2502       \u251c\u2500\u2500 __init__.py        # Re-exports run_relay\n\u2502       \u2514\u2500\u2500 relay.py           # WebSocket server logic\n\u251c\u2500\u2500 docs/                      # Documentation (MkDocs source)\n\u2502   \u251c\u2500\u2500 index.md\n\u2502   \u251c\u2500\u2500 installation.md\n\u2502   \u2514\u2500\u2500 ...                    # Other .md files\n\u251c\u2500\u2500 examples/                  # Usage examples/scripts\n\u251c\u2500\u2500 tests/                     # Tests of specific and all functionality\n\u251c\u2500\u2500 pyproject.toml             # Build/config\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 LICENSE\n</code></pre>"},{"location":"layout/#key-modules","title":"Key Modules","text":""},{"location":"layout/#p2p_copy","title":"p2p_copy","text":"<p>Main library package. Installs as <code>p2p_copy</code>.</p> <ul> <li><code>__init__.py</code>: Defines <code>__version__</code>, re-exports <code>send</code>, <code>receive</code>, <code>CompressMode</code>.</li> <li><code>api.py</code>: High-level async APIs for sending/receiving. Handles connections, transfers, and feature logic.</li> <li><code>compressor.py</code>: <code>Compressor</code> class for per-file Zstd compression (auto/on/off modes).</li> <li><code>io_utils.py</code>: Utilities for async file reading (<code>read_in_chunks</code>), checksum computation (<code>compute_chain_up_to</code>), manifest building (<code>iter_manifest_entries</code>).</li> <li><code>protocol.py</code>: Protocol definitions: dataclasses (<code>Hello</code>, <code>Manifest</code>), framing (<code>pack_chunk</code>/<code>unpack_chunk</code>), constants (e.g., <code>READY</code>, <code>EOF</code>).</li> <li><code>security.py</code>: <code>ChainedChecksum</code> for integrity, <code>SecurityHandler</code> for end-to-end encryption.</li> </ul>"},{"location":"layout/#p2p_copy_cli","title":"p2p_copy_cli","text":"<p>CLI entrypoint package.</p> <ul> <li><code>main.py</code>: Typer app with commands (<code>send</code>, <code>receive</code>, <code>run-relay-server</code>).</li> </ul>"},{"location":"layout/#p2p_copy_server","title":"p2p_copy_server","text":"<p>Standalone relay package.</p> <ul> <li><code>__init__.py</code>: Re-exports <code>run_relay</code>.</li> <li><code>relay.py</code>: Async WebSocket server: pairing logic, bidirectional piping, TLS support.</li> </ul>"},{"location":"layout/#non-installable-folders","title":"Non-Installable Folders","text":"<ul> <li><code>docs/</code>: MkDocs Markdown sources; build with <code>mkdocs build</code>.</li> <li><code>examples/</code>: Runnable scripts/demos.</li> <li><code>tests/</code>: Pytest suite; run with <code>pytest</code>.</li> </ul> <p>For installation, see Installation. For troubleshooting contributions, see Troubleshooting.</p>"},{"location":"relay/","title":"Relay Setup","text":"<p>The relay server pairs senders and receivers using their shared code hash, forwarding data without storage. It supports TLS and binds to a specified host and port. One sender and one receiver are allowed per code.</p> <p>For security details, see Security. For CLI usage, see Usage.</p>"},{"location":"relay/#quick-start","title":"Quick Start","text":"<p>For development (no TLS):</p> <pre><code>p2p-copy run-relay-server localhost 8765 --no-tls\n</code></pre> <p>For production (TLS recommended): 1. Already have or generate trusted TLS certificates (e.g., via Let's Encrypt). 2. Run:    <code>bash    p2p-copy run-relay-server 0.0.0.0 443 \\    --certfile /etc/letsencrypt/live/relay.example.com/fullchain.pem \\    --keyfile /etc/letsencrypt/live/relay.example.com/privkey.pem</code></p>"},{"location":"relay/#configuration","title":"Configuration","text":""},{"location":"relay/#tls","title":"TLS","text":"<ul> <li>Enabled by default or explicitly with <code>--tls</code>.</li> <li>Requires <code>--certfile</code> and <code>--keyfile</code> (PEM format).</li> <li>Generate certificates using tools like Certbot:</li> </ul> <pre><code>sudo certbot certonly --standalone -d relay.example.com # --register-unsafely-without-email\n</code></pre> <ul> <li>Set up renewal via crontab:</li> </ul> <pre><code>sudo crontab -e\n# Add: 0 4 * * * certbot renew --deploy-hook \"systemctl reload run-relay-server.service\"\n</code></pre>"},{"location":"relay/#port-privileges","title":"Port Privileges","text":"<ul> <li>Ports below 1024 (e.g., 443) require elevated privileges.</li> <li>Run as root or use capabilities (e.g., <code>setcap</code> for specific permissions).</li> <li>Using port forwarding or a reverse proxy might also be elegant solutions. </li> </ul>"},{"location":"relay/#logging","title":"Logging","text":"<ul> <li>Logs to stdout (or a file if redirected).</li> <li>Suppresses verbose handshake errors caused by non-WebSocket traffic.</li> <li>Minimal output on localhost for testing.</li> </ul>"},{"location":"relay/#scaling","title":"Scaling","text":"<ul> <li>Low CPU and memory usage due to I/O-focused design.</li> <li>No persistence; restarts clear pairings.</li> <li>Performance limited by network bandwidth.</li> </ul>"},{"location":"relay/#deployment","title":"Deployment","text":""},{"location":"relay/#systemd-service","title":"Systemd Service","text":"<ul> <li>Use a service to perpetually run and restart the relay </li> <li>it will log to a file</li> <li>Create the service file <code>/etc/systemd/system/run-relay-server.service</code>:</li> </ul> <pre><code>[Unit]\nDescription=WebSocket File-Forwarding Server\nAfter=network.target\n\n[Service]\nType=simple\nWorkingDirectory=/root\nStandardOutput=append:/root/run-relay-server.log\nStandardError=inherit\nExecStart=/root/.venv/bin/p2p-copy run-relay-server 0.0.0.0 443 --certfile /etc/letsencrypt/live/relay.example.com/fullchain.pem --keyfile /etc/letsencrypt/live/relay.example.com/privkey.pem\nRestart=on-failure\nRestartSec=5s\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>Enable and start:</p> <pre><code>sudo systemctl daemon-reload\nsudo systemctl enable --now run-relay-server.service\n</code></pre>"},{"location":"relay/#firewall","title":"Firewall","text":"<ul> <li>Open the bound port (e.g., 443).</li> <li>No additional ports required.</li> </ul> <p>For common issues, see Troubleshooting. For features, see Features.</p>"},{"location":"security/","title":"Security","text":"<p>p2p-copy incorporates security measures for pairing, integrity, and optional confidentiality. The design is suitable for HPC and other restricted networks. Depending on which features are used, users can decide whether to elevate security or to maximize performance. For features overview, see Features. For installation with security extras, see Installation.</p> <p>Note: open Security in Pages or Security in docs for relative links to work. </p>"},{"location":"security/#core-security-elements","title":"Core Security Elements","text":"<ul> <li>Code Hashing for Pairing: The shared code is hashed (SHA-256 by default) before transmission. With encryption, Argon2id is used for key derivation and resistance to brute-force attacks.</li> <li>Transport Security: Relay supports TLS (WSS) to protect against eavesdropping and man-in-the-middle attacks. Enabled via <code>--tls</code> with certificates.</li> <li>Integrity Verification: Chained SHA-256 checksums on chunks ensure data is not corrupted or reordered. </li> <li>No Relay Storage: Data is forwarded in real-time; no persistence reduces exposure.</li> </ul>"},{"location":"security/#optional-end-to-end-encryption","title":"Optional End-to-End Encryption","text":"<ul> <li>Enabled via <code>--encrypt</code>: Uses AES-256-GCM for authenticity and confidentiality. Keys derived from the code via Argon2id (time_cost=3, memory_cost=32 MiB, parallelism=8).</li> <li>AES-GCM-Nonce Management: Chained nonces (SHA-256) prevent reuse and ensure uniqueness per chunk.</li> <li>Scope: Encrypts manifests, file headers, and payloads. Transport TLS remains independent.</li> <li>Dependencies: Requires <code>argon2-cffi</code> and <code>cryptography</code> (installed with <code>[security]</code> extras).</li> <li>Performance Trade-off: Adds CPU overhead. The actual transfer time should not noticeably increase.    </li> </ul>"},{"location":"security/#threat-model","title":"Threat Model","text":"<ul> <li>Protections Against:<ul> <li>Eavesdropping: TLS and optional E2EE.</li> <li>Tampering: Checksums and GCM authentication.</li> <li>Brute-Force Attacks: Hashed codes; long, random and unique codes are recommended.</li> <li>Replay Attacks: Sequential nonces and checksums.</li> </ul> </li> <li>Limitations: Weak codes are vulnerable to guessing. Theoretically no forward secrecy. </li> </ul>"},{"location":"security/#best-practices","title":"Best Practices","text":"<ul> <li>Use TLS on the relay for all production deployments.</li> <li>Enable E2EE for confidential data.</li> <li>Generate strong codes.</li> <li>Verify certificates when connecting to public relays.</li> </ul> <p>For code details, see <code>security.py</code> in Module Layout. For common security issues, see Troubleshooting.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>This page addresses common issues with p2p-copy. For setup, see Installation and Relay Setup. For usage, see Usage.</p>"},{"location":"troubleshooting/#connection-problems","title":"Connection Problems","text":"<ul> <li>No Connection to Relay: Ensure relay is running and accessible. Check firewall rules allow the port.</li> <li>Timeout Waiting for peer: Sender and receiver must use the same code, encrypt flag and relay.</li> <li>Handshake Failed: Non-WebSocket traffic caused by use of the wrong protocol (i.e. WS instead of WSS)</li> <li>Duplicate Role for Code: Two senders or receivers with the same code. Use unique codes per pair.</li> </ul>"},{"location":"troubleshooting/#transfer-errors","title":"Transfer Errors","text":"<ul> <li>Chained Checksum Mismatch: Data corruption in transit. Retry; check network stability.</li> <li>Size Mismatch: Incomplete transfer. Use <code>--resume</code> to continue.</li> <li>Unexpected Frame/Control: Protocol violation. Ensure matching versions of sender/receiver. <p>Note: No transfer errors were actually encountered in testing.</p> </li> </ul>"},{"location":"troubleshooting/#encryption-issues","title":"Encryption Issues","text":"<ul> <li>ModuleNotFoundError for Security Libs: Install with <code>[security]</code> extras. See Installation.</li> </ul>"},{"location":"troubleshooting/#performance-and-resource-issues","title":"Performance and Resource Issues","text":"<ul> <li>High RAM Usage on Transfer Start: Encryption uses memory-hard KDF which temporarily spikes memory usage.</li> <li>Slow Transfers: Slow network speed of either relay, sender or receiver will limit transfer speed. </li> </ul>"},{"location":"troubleshooting/#relay-specific","title":"Relay-Specific","text":"<ul> <li>Port Binding Fails: Privileges needed for low ports. Run as root or use higher ports for testing.</li> <li>TLS Errors: Invalid or untrusted certificates. Use Certbot for valid ones; check file paths.</li> <li>No Logs on Localhost: Expected for testing; deploy to non-localhost for full logging.</li> </ul>"},{"location":"troubleshooting/#general-tips","title":"General Tips","text":"<ul> <li>Test locally with <code>--no-tls</code> and on user-space ports.</li> <li>If using a relay service check the system logs (systemd status).</li> <li>If issues persist, review code or report on GitHub.</li> </ul> <p>For security-related troubleshooting, see Security. For features, see Features.</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#overview","title":"Overview","text":"<p>p2p-copy facilitates file transfers via a WebSocket relay. The workflow involves starting a relay server, then running sender and receiver clients with a shared code for pairing. The relay forwards data without storage, supporting multiple client pairs.</p> <p>For protocol details, see Features. For API usage in scripts, see API and APIExamples.</p>"},{"location":"usage/#get-usage-info-in-terminal","title":"Get usage info in terminal","text":"<pre><code>p2p-copy --help\np2p-copy send --help\np2p-copy receive --help\np2p-copy run-relay-server --help\n</code></pre>"},{"location":"usage/#cli-commands","title":"CLI Commands","text":"<p>The CLI is built with Typer and provides three main commands: <code>send</code>, <code>receive</code>, and <code>run-relay-server</code>.</p>"},{"location":"usage/#p2p-copy-send","title":"p2p-copy send","text":"<p>Transfers files or directories to a receiver.</p> <pre><code>p2p-copy send &lt;server&gt; &lt;code&gt; &lt;files_or_dirs&gt; [OPTIONS]\n</code></pre> <p>Arguments: - <code>&lt;server&gt;</code>: Relay URL (e.g., <code>ws://localhost:8765</code> or <code>wss://relay.example:443</code>). - <code>&lt;code&gt;</code>: Shared passphrase for pairing (hashed internally). - <code>&lt;files_or_dirs&gt;</code>: Files or directories to send (recursive for directories).</p> <p>Options: - <code>--encrypt</code>: Enable end-to-end encryption (requires <code>[security]</code> install). - <code>--compress &lt;MODE&gt;</code>: Compression mode (<code>auto</code>, <code>on</code>, or <code>off</code>; default: <code>auto</code>). - <code>--resume</code>: Enable resume (skip complete files and append partial ones).</p> <p>Examples:</p> <pre><code># Basic file transfer\np2p-copy send ws://localhost:8765 mycode file.txt\n\n# Directory with encryption and resume\np2p-copy send wss://relay.example:443 mycode /path/to/dir --encrypt --resume\n\n# Multiple files with forced compression\np2p-copy send ws://localhost:8765 mycode *.log --compress on\n</code></pre>"},{"location":"usage/#p2p-copy-receive","title":"p2p-copy receive","text":"<p>Receives files into a specified directory.</p> <pre><code>p2p-copy receive &lt;server&gt; &lt;code&gt; [OPTIONS]\n</code></pre> <p>Arguments: - <code>&lt;server&gt;</code>: Relay URL (same as sender). - <code>&lt;code&gt;</code>: Shared passphrase (must match sender).</p> <p>Options: - <code>--encrypt</code>: Enable decryption (must match sender). - <code>--out &lt;DIR&gt;</code>: Output directory (default: current directory).</p> <p>Examples:</p> <pre><code># Receive to current directory\np2p-copy receive ws://localhost:8765 mycode\n\n# Receive to custom directory with encryption\np2p-copy receive wss://relay.example:443 mycode --out ./downloads --encrypt\n</code></pre>"},{"location":"usage/#p2p-copy-run-relay-server","title":"p2p-copy run-relay-server","text":"<p>Starts the relay server.</p> <pre><code>p2p-copy run-relay-server &lt;host&gt; &lt;port&gt; [OPTIONS]\n</code></pre> <p>Arguments: - <code>&lt;host&gt;</code>: Bind host (e.g., <code>localhost</code> or <code>0.0.0.0</code>). - <code>&lt;port&gt;</code>: Bind port (e.g., <code>8765</code> or <code>443</code>).</p> <p>Options: - <code>--tls</code> / <code>--no-tls</code>: Enable/disable TLS (default: enabled). - <code>--certfile &lt;PATH&gt;</code>: TLS certificate PEM file. - <code>--keyfile &lt;PATH&gt;</code>: TLS private key PEM file.</p> <p>Examples:</p> <pre><code># Development relay without TLS\np2p-copy run-relay-server localhost 8765 --no-tls\n\n# Production relay with TLS\np2p-copy run-relay-server 0.0.0.0 443 --tls --certfile cert.pem --keyfile key.pem\n</code></pre>"},{"location":"usage/#typical-workflow","title":"Typical Workflow","text":"<ol> <li>Start the relay (see Relay Setup).</li> <li>Run the receiver (it waits for the sender).</li> <li>Run the sender with matching code and server URL.</li> </ol> <p>Example in three terminals:</p> <pre><code># Terminal 1: Relay\np2p-copy run-relay-server localhost 8765 --no-tls\n</code></pre> <pre><code># Terminal 2: Receiver\np2p-copy receive ws://localhost:8765 demo --out ./downloads\n</code></pre> <pre><code># Terminal 3: Sender\necho \"hello test\" &gt; sample.txt\np2p-copy send ws://localhost:8765 demo sample.txt\nrm sample.txt\n</code></pre> <p>The receiver saves <code>sample.txt</code> in <code>./downloads</code>. Both clients exit on completion; the relay persists.</p>"},{"location":"usage/#notes","title":"Notes","text":"<ul> <li>Pairing occurs via code hash. Start the relay first; sender and receiver order is flexible.</li> <li>Errors result in non-zero exit codes (e.g., timeouts, mismatches).</li> <li>For security considerations, see Security. For issues, see Troubleshooting.</li> </ul>"}]}